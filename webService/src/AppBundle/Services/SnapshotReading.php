<?php
/**
 */
namespace AppBundle\Services;

use AppBundle\Entity;
use AppBundle\RessourceProvider\RessourceFactory;
use AppBundle\Services\EntityCreator;
use Doctrine\DBAL\Exception\UniqueConstraintViolationException;
use Doctrine\ORM\EntityManager;
use Symfony\Bundle\FrameworkBundle\Controller\Controller;
use Symfony\Component\Config\Definition\Exception\Exception;
use Symfony\Component\DependencyInjection\ContainerAwareInterface;
use Symfony\Component\DependencyInjection\ContainerAwareTrait;
use Symfony\Component\HttpFoundation\Response;
use Symfony\Component\Validator\Constraints\DateTime;
use Symfony\Component\DependencyInjection\ContainerInterface as Container;

// READ AND PERSIST DATA

class SnapshotReading
{
    /**
     * @var EntityManager
     * @var string snapshot_reading.script
     */
    public $em;
    private $parsingScript;
    private $ressourceFactory;
    private $auditEngine;
    public function __construct(RessourceFactory $ressourceFactory,EntityManager $entityManager, $scriptPath, $scriptName, $snapshotBaseDir,$auditEngine)
    {
        $this->ressourceFactory = $ressourceFactory;
        $this->em = $entityManager;
        $this->parsingScript = $scriptPath . $scriptName;
        $this->auditEngine = $auditEngine;
    }

    /**
     * @param string $fileName le nom du statsPack
     * @return string le json correspondent au statspack
     */
    // GENERATE A JSON WITH PYTHON SCRIPT FROM THE STATSPACK - CALL STATSPACKREADING SCRIPT
    private function generateJsonFromStatPack($snapshotDirectory,$fileName,$client='')
    {
        $snap_json = exec("python " . $this->parsingScript . " " . $snapshotDirectory . " " . $fileName . " " . $client);
        return $snap_json;
    }

    /**
     * take a snapshot in a form of a Json and add it in the Database via doctrine entities
     * generated by a @link EntityFactory
     * @param string $json
     */
    private function addSnapshotFromJson($json)
    {
        $jsonDecodedSnapshot = json_decode($json, true);
        /*
         * $jsonDecodedSnapshot['startDate'] = \DateTime::createFromFormat('j-M-y H:i:s', $jsonDecodedSnapshot['startDate']);
         * $jsonDecodedSnapshot['endDate'] = \DateTime::createFromFormat('j-M-y H:i:s', $jsonDecodedSnapshot['endDate']);
         */
        $client = $this->em->getRepository('AppBundle\Entity\Client')->findOneBy(['name'=>$jsonDecodedSnapshot['clientName']]);
        $database = $this->em->getRepository('AppBundle\Entity\Base\Base')->findOneBy(['name' => $jsonDecodedSnapshot['dataBaseName'], 'client' => $client->getId()]);
        if ($database == null) {
            throw new Exception("DataBase : " . $jsonDecodedSnapshot['dataBaseName'] . "not found");
        }
        /* @var $instance Entity\Base\Instance */
        $instance = $this->em->getRepository('AppBundle\Entity\Base\Instance') // Search for INSTANCE by - name-base id-serverName -
            ->findOneBy([
                'name' => $jsonDecodedSnapshot['instanceName'],
                'base' => $database->getId(),
                'serverName' =>  $jsonDecodedSnapshot['serverName']
            ]);
        $instanceMetadata =  $this->em->getRepository('AppBundle\Entity\Metadata\InstanceMetadata') // Search for INSTANCEMETADATA by - instance id -
            ->findOneBy([
                'instance' => $instance->getId()
            ]);
        if ($instance === null) {
            throw new Exception("Instance : " . $jsonDecodedSnapshot['instanceName'] . " (from dataBase " . $jsonDecodedSnapshot['dataBaseName'] . ") not found");
        }
        if ($instanceMetadata === null){
            $instanceMetadata = new Entity\Metadata\InstanceMetadata();
            $this->em->persist($instanceMetadata);
        }
        $snapshotId = 0;
        // Search for snapshot from startDate - if exist - save it to var snapshotEntity and delete it from memory...?
        if (!empty($instance->getSnapshotsForStartDate( \DateTime::createFromFormat('j-M-y H:i:s', $jsonDecodedSnapshot['startDate'])))) {
            $snapshotEntity = $instance->getSnapshotsForStartDate( \DateTime::createFromFormat('j-M-y H:i:s', $jsonDecodedSnapshot['startDate']));
            $this->em->remove($snapshotEntity);
            // test debug - print "\nremove : ".$snapshotEntity->getId()." date : ".$jsonDecodedSnapshot['startDate']."\n";
            $snapshotId = $snapshotEntity->getId();
            $this->em->flush();
            // test debug - print "\nsnapshotId removed: ".$snapshotId."\n";
            // test debug - print "\nsnapshotGetId removed: ".$snapshotEntity->getId()."\n";
        }
        unset($jsonDecodedSnapshot['instanceName'], $jsonDecodedSnapshot['dataBaseName']); // destroy instanceName and dataBaseName
        try {

            if($snapshotId == 0 || $snapshotEntity->getId() != $snapshotId){
                $snapshotEntity = new Entity\Snapshots\Snapshot(); // Create new snapshot object
                $this->ressourceFactory->get('snapshot')->updateFromJson($snapshotEntity,json_encode($jsonDecodedSnapshot));
                $snapshotEntity->setInstance($instance);
                $nbSnapshot = $instanceMetadata->getNbSnapshot();
                $instanceMetadata->setNbSnapshot($nbSnapshot+1);
                $instanceMetadata->setInstance($instance->getId());
                // START TEST QUERY
                // test debug - $snapshotEntity->displaySnapshotInfos();
                $format = "Y-m-d H:i:s";
                $dateDeb = date_create_from_format('j-M-y H:i:s', $jsonDecodedSnapshot['startDate']);
                $dateEnd = date_create_from_format('j-M-y H:i:s', $jsonDecodedSnapshot['endDate']);

                $startDate = date_create_from_format($format, $dateDeb->format($format));
                $endDate = date_create_from_format($format, $dateEnd->format($format));
                $sD = '';
                $eD = '';
                $sD = $startDate->format($format);
                $eD = $endDate->format($format);

                // select query to check if snapshot with unity constraint -startDate - endDate - instanceId- exists
                $query = "SELECT * FROM snapshot WHERE start_date='$sD' and end_date='$eD' and instance_id=".$instance->getId().";";
                // test debug - $snapshotId = $snapshotEntity->getId();
                // test debug - print "\n".$query."\n";
                $statement = $this->em->getConnection()->prepare($query);
                $statement->execute();
                $result = $statement->fetchAll();

            if(count($result)>0){
                // test debug - print "\nok, it exist ".count($result);
                // test debug - print "\ninstance ".$instance->getId();
                // test debug - print "\n".$snapshotEntity->getStartDate()->format('Y-m-d H:i:s')."\n"."date";
            }else{
                // test debug - print "\ndoesn't exist ".count($result);
                // test debug - print "\n".$snapshotEntity->getStartDate()->format('Y-m-d H:i:s')."\n"."date";
                $this->em->persist($snapshotEntity); // persist snapshot

                $this->em->persist($instanceMetadata);
                $this->em->flush();
                $this->persistNotes($snapshotEntity);
                // INSERT DONE
            }

            // END TEST
                // test debug - print "\ndone\n";
            }
            else{
                // NOTHIN DONE
                // test debug - print "\nnothing to do...\n";
            }
        } catch (Exception $e) {
            throw $e;
        }
    }

    private function addDataBaseFromJson($json)
    {
        // TEST MODIF TRY CATCH
        try{
            $base = json_decode($json, true);
            $client = $this->em->getRepository('AppBundle\Entity\Client')->findOneByName($base['clientName']);
            $baseEntity = new Entity\Base\Base();
            $baseEntity->updateFromJson(json_encode($base));
            $baseEntity->setClient($client);
            $this->em->persist($baseEntity);
            $this->em->flush();
        } catch (Exception $e) {
            throw $e;
        }
    }

    /**
     * @param Entity\Base\Base $baseEntity
     */
    private function updateDataBaseFromJson($json, $baseEntity)
    {
        $base = json_decode($json, true);
        $instances = $base['Instance'];
        /* @var $instance Entity\Base\Instance */
        foreach ($instances as $instance) {
            $instanceName = $instance['name'];
            if ($instanceEntity = $baseEntity->getInstanceByNameAndServerName($instanceName,$instance['serverName'])) {
                // TEST MODIF TRY CATCH
                try{
                    $this->ressourceFactory->get('instance')->updateFromJson($instanceEntity,json_encode($instance));
                    $this->em->merge($instanceEntity);
                    $this->em->flush();
                } catch (Exception $e) {
                    throw $e;
                }                
            } else {
                // TEST MODIF TRY CATCH
                try{
                    $instanceEntity = new Entity\Base\Instance();
                    $this->ressourceFactory->get('instance')->updateFromJson($instanceEntity,json_encode($instance));
                    $baseEntity->addInstance($instanceEntity);
                    $this->em->persist($instanceEntity);
                    $this->em->merge($baseEntity);
                    $this->em->flush();
                } catch (Exception $e) {
                    throw $e;
                }
            }
        }
    }
    /*
    *   this function take a statsPack/awr, decode it and insert it in a dataBase
    */
    public function loadSnapshot($dir,$fileName,$clientName='')
    {
    $pythonOutput = $this->generateJsonFromStatPack($dir,$fileName,$clientName); # Generate the sp name from filename and get it
        $jsonDecoded = json_decode($pythonOutput, true);
        $this->em->beginTransaction();
        if ($jsonDecoded === null || $jsonDecoded === ""){ // If JSON is empty
            throw new Exception("\33[1;33mParser Error : file cannot be parsed, wrong or missing informations inside statspack\33[0m\n".$pythonOutput);
            print("jsonDecoded value: ".$jsonDecoded);
        }
        # Add test function to display result
        /* @var $client Entity\Client */
        $client = $this->em->getRepository('AppBundle\Entity\Client')->findOneByName($jsonDecoded['Base']['clientName']);
        if (!$client) {
            throw new Exception("\33[1;33mle client \"" . $jsonDecoded['Base']['clientName'] . "\" n'existe pas... Ou le nom ne correspond pas, ou il doit d'abord etre cree manuellement..\33[0m");
        }
        if ($jsonDecoded['Base']) {// the json contains informations about the dataBase so we can create or update it
            /* @var $baseEntity Entity\Base\Base */
            $baseEntity = $this->em->getRepository('AppBundle\Entity\Base\Base')->findOneBy(['name' => $jsonDecoded['Base']['name'], 'client' => $client->getId()]);
            if ($baseEntity) {//the database already exist so we update it
                $this->updateDataBaseFromJson(json_encode($jsonDecoded['Base']), $baseEntity);
            } else {//the base dont exist
                $this->addDataBaseFromJson(json_encode($jsonDecoded['Base']));
            }
            unset($jsonDecoded['Base']);
        }
        if ($jsonDecoded['Snapshot']) {//the json contains a snapshot (state of the base during a given time)
            $this->addSnapshotFromJson(json_encode($jsonDecoded['Snapshot']));
        } else {
            throw new Exception("snapshotNotFound");
        }
        $this->em->commit();
        $this->em->clear();
        gc_collect_cycles();
        return $pythonOutput;
    }

    /**
     * @param $snapshot Entity\Snapshots\Snapshot
     */
    private function persistNotes($snapshot){
        $noteEngines = $this->em->getRepository('AppBundle\Entity\AuditEngine\NoteEngine')->findAll();

        /* @var $noteEngine Entity\AuditEngine\NoteEngine*/
        foreach ($noteEngines as $noteEngine){
            if($noteEngine->isStored()){
                // TEST MODIF TRY CATCH
                try{
                    /* @var $auditEngine \AppBundle\Services\AuditEngine*/
                    $auditEngine = $this->auditEngine;
                    $note = new Entity\Snapshots\Note();
                    $noteName = $noteEngine;
                    $note->setNoteEngine($noteName);
                    $note->setValue($auditEngine->getNoteValue($noteName,$snapshot));
                    $this->em->persist($note);
                    $snapshot->addNote($note);

                    $this->em->persist($snapshot);
                    $this->em->flush();
                } catch (\Doctrine\DBAL\Exception $e) {
                    print $e;
                }
            }
        }
    }

    // create function to parse xml file to get EDITION info
    private function readEdition(){
        
    }
}
